/*
TOTP2GO
by Tim Lau

Use of this source code is governed by an MIT-style
license that can be found in the LICENSE file or at
https://opensource.org/licenses/MIT.

For more info, please visit our Github repo:
https://github.com/studenttwok/TOTP2GO
*/

#include <EEPROM.h>
#include <time.h>
#include <WiFi.h>
#include <mbedtls/base64.h>
#include "pb_encode.h"
#include "pb_decode.h"
#include "google_auth.pb.h"
#include <Base32.h>
#include <M5StickCPlus.h>
#include <SimpleHOTP.h>

////////// SECTION 1: SETTING BEGIN //////////
const char* ssid     = "Your Wifi SSID here";
const char* password = "Your Wifi Password here";
const char* ntpServer = "pool.ntp.org"; // or other NTP server you did prefer
const char* timezone_str = "HKT-8";  // Please refer to https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv . Find the appropriate value from the second column and use it to replace HKT-8

// Data parameter is obtained from the export URL which is generated by GOOGLE authenticator (In base64 encoded format), eg: otpauth-migration://offline?data=Ci4KFFNlY3JlN1AhQWluJGVjcmV0S2V5EhBQbGFpbiBTZWNyZXQgS2V5IAEoATACEAEYASAAKPXz5N0H
// Please replace Ci4KFFNlY3JlN1AhQWluJGVjcmV0S2V5EhBQbGFpbiBTZWNyZXQgS2V5IAEoATACEAEYASAAKPXz5N0H with your own value.
char googleAuthData[] = "Ci4KFFNlY3JlN1AhQWluJGVjcmV0S2V5EhBQbGFpbiBTZWNyZXQgS2V5IAEoATACEAEYASAAKPXz5N0H"; 

////////// SETTING END //////////

#define MAX_KEY_ENTRIES_NUM 30
typedef struct _otp_parms {
  char name[128];
  char secret[128];
  int otp_type;
} OTP_Parms;

Base32 base32;
OTP_Parms keyList[MAX_KEY_ENTRIES_NUM];  // Max we support 30 entries
int numOfKeyEntry = 0;  // Store how much entries we have
int screen = 0; //0: otoplist, 1: sync screen
int pageOffset = 0;
const int pageSize = 5;
long previousMillis = 0;
long refreshInterval = 1000;

void setup () {
  // print the value:
  Serial.begin(115200);

  M5.begin();
  M5.Axp.EnableCoulombcounter();
  
  // Retrieve Time from RTC
  retrieveTimeFromRTC();

  bool googleAuthResult = parseGoogleAuthData(googleAuthData);

  ////////// SECTION 2: Add your other secret data - BEGIN //////////
  // add more entries if needed, we support secret in Base32-encoded string or plain text
  // 
  // Format: 
  // parseNameAndBase32Key("NAME", "SECRET IN BASE32"); // Secret in Base32-encoded string
  // parseNameAndPlainKey("NAME", SECRET IN PLAIN");  // Secret in plain text


  ////////// Add your other secret data - END //////////

  Serial.print("Total imported entries: ");
  Serial.println(numOfKeyEntry);
}


void loop () {
  if(millis() - previousMillis >= refreshInterval) {
    // Don't redraw too fast
    previousMillis = millis();

    if (screen == 0) {
      // display totp list
      displayTOTPList();
    } else if (screen == 1){
      // display NTP Sync screen
      displayAndSyncTimeFromNTP();
    }
  }

  // Handle user event
  if (screen == 0) {
    if (M5.BtnA.wasReleased()) {
      if (((pageOffset*pageSize) + pageSize) >= numOfKeyEntry) {
        // Last page, toggle back to first page
        pageOffset = 0;
      } else {
        pageOffset++;
      }
    } else if (M5.BtnB.wasReleasefor(700)) {
      // switch to NTP SYNC screen
      screen = 1;
      pageOffset = 0;
    }
  } else if (screen == 1) {
    // nothing on NPT SYNC Screen
  }

  M5.update();
}

void displayAndSyncTimeFromNTP() {
  // display
  // Screen size: 135 x 240

  // Clear Screen
  M5.Lcd.fillScreen(BLACK);
  M5.Lcd.setTextColor(WHITE);
  M5.Lcd.setCursor(5, 5);
  M5.Lcd.setTextSize(1);

  // Indicator: Date Time
  M5.Lcd.setTextSize(1);
  M5.Lcd.setCursor(5, 5);
  M5.Lcd.printf("TOTP2GO");
  M5.Lcd.setCursor(5, 15);
  M5.Lcd.printf("NTP Time Sync");

  // Draw a line
  M5.Lcd.drawFastHLine(0, 28, 135, TFT_GREEN);

  M5.Lcd.setCursor(0, 30);
  M5.Lcd.printf("Connecting WIFI:\n");

  // Ref: https://randomnerdtutorials.com/esp32-date-time-ntp-client-server-arduino/
  Serial.println("=====retrieveTimeFromInternet()=====");
  Serial.printf("Connecting to Wifi AP: %s", ssid);

  M5.Lcd.setTextColor(YELLOW);
  M5.Lcd.printf("%s\n", ssid);

  M5.Lcd.setTextColor(WHITE);

  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");

    M5.Lcd.printf(".");
  }
  Serial.println("");
  Serial.println("WiFi connected.");


  M5.Lcd.printf("\nWifi Connected.\n");
  M5.Lcd.printf("Sync from:\n");
  M5.Lcd.setTextColor(YELLOW);
  M5.Lcd.printf("%s\n", ntpServer);
  M5.Lcd.setTextColor(WHITE);

  delay(2000);
  // Init and get the time
  //configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
  configTime(0, 0, ntpServer);
  //printLocalTime();
  delay(3000);

  //disconnect WiFi as it's no longer needed
  WiFi.disconnect(true);
  WiFi.mode(WIFI_OFF);

  M5.Lcd.printf("Wifi Disconnected.\n");

  // try to get the timeinfo
  struct tm timeinfo;
  if(!getLocalTime(&timeinfo)){
    Serial.print("Failed to obtain time from NTP: ");
    Serial.println(ntpServer);

    M5.Lcd.setTextColor(RED);
    M5.Lcd.printf("\nSync Fail.\nTry again later.\n");
    M5.Lcd.setTextColor(WHITE);

    delay(2000);

    // Back to TOTP Screen
    screen = 0;

    return;
  }

  // set timezone
  setenv("TZ", timezone_str, 1);
  tzset();

  // Save to RTC
  RTC_TimeTypeDef timeStruct_RTC;
  RTC_DateTypeDef dateStruct_RTC;

  timeStruct_RTC.Hours   = timeinfo.tm_hour;  // 0-23
  timeStruct_RTC.Minutes = timeinfo.tm_min;   // 0-59
  timeStruct_RTC.Seconds = timeinfo.tm_sec;   // 0-61
  M5.Rtc.SetTime(&timeStruct_RTC);

  //dateStruct_RTC.WeekDay = timeinfo.tm_wday + 1;    // RTC is 1(Sun)-7(Sat), tm is 0(Sun)-6(Sat)
  dateStruct_RTC.Month   = timeinfo.tm_mon; // 0-11
  dateStruct_RTC.Date    = timeinfo.tm_mday;  // 1-31
  dateStruct_RTC.Year    = timeinfo.tm_year + 1900; // RTC is YYYY, tm is 1900+
  M5.Rtc.SetData(&dateStruct_RTC);

  // are we daylightsaving now?
  EEPROM.put(0, timeinfo.tm_isdst);

  Serial.println("Time sync successfully");
  Serial.println("RTC setting is saved");

  M5.Lcd.setTextColor(GREEN);
  M5.Lcd.printf("\nNTP Sync Success.\nDateTime is saved.\n");
  M5.Lcd.setTextColor(WHITE);

  delay(2000);

  // Back to TOTP Screen
  screen = 0;
}

void displayTOTPList() {
  // get current time
  // try to get the timeinfo
  struct tm timeinfo;
  if(!getLocalTime(&timeinfo)){
    Serial.print("Failed to obtain time from NTP: ");
    Serial.println(ntpServer);
    return;
  }

  // display
  // Screen size: 135 x 240

  // Clear Screen
  M5.Lcd.fillScreen(BLACK);
  M5.Lcd.setTextColor(WHITE);

  // Display: Indicator
  // Indicator: Date Time
  M5.Lcd.setTextSize(1);
  M5.Lcd.setCursor(5, 5);
  M5.Lcd.printf("%04d-%02d-%02d", timeinfo.tm_year + 1900, timeinfo.tm_mon + 1, timeinfo.tm_mday);
  M5.Lcd.setCursor(5, 15);
  M5.Lcd.printf("%02d:%02d:%02d %s", timeinfo.tm_hour, timeinfo.tm_min, timeinfo.tm_sec, timeinfo.tm_isdst?"DST":"");

  // Indicator: Battery
  M5.Lcd.setCursor(74, 5);
  M5.Lcd.setTextColor(CYAN);
  M5.Lcd.printf("Bat:%.2fv", M5.Axp.GetBatVoltage());
  M5.Lcd.setTextColor(WHITE);

  // Indicator: APP Name
  M5.Lcd.setCursor(85, 15);
  M5.Lcd.printf("TOTP2GO");

  // Indicator: separation line
  M5.Lcd.drawFastHLine(0, 28, 135, TFT_GREEN);

  // Display: list
  int x = 5;
  int y = 30;
  M5.Lcd.setTextSize(2);
  M5.Lcd.setTextWrap(false);
  for (int i=pageOffset*pageSize; i < (pageOffset*pageSize) + pageSize; i++) {

    // check if it has no name, so we can skip
    if (strlen(keyList[i].name) == 0) {
      break;
    }

    char totp[10] = {0};
    bool result = getOTPByIndex(i, totp);

    // display the result
    //M5.Lcd.printf("%d: %s\n  %s", i+1, keyList[i].name, totp);
    //M5.Lcd.printf("%s\n  %s", keyList[i].name, totp);
    //M5.Lcd.printf("%s\n  %s", keyList[i].name, totp);
    M5.Lcd.setTextColor(LIGHTGREY);
    M5.Lcd.setCursor(x, y);
    M5.Lcd.printf("%.10s", keyList[i].name, totp);

    M5.Lcd.setTextColor(YELLOW);
    M5.Lcd.setCursor(x, y+18);
    M5.Lcd.printf("  %s", totp);
    y = y + 40;
  }

  // Display: Page Size
  M5.Lcd.setTextWrap(true);
  int totalPage = numOfKeyEntry / pageSize;
  if (numOfKeyEntry % pageSize > 0) {
    totalPage++;
  }
  M5.Lcd.setTextColor(ORANGE);
  M5.Lcd.setCursor(100, 230);
  M5.Lcd.setTextSize(1);
  M5.Lcd.printf("%02d/%02d", pageOffset+1, totalPage);

}

void retrieveTimeFromRTC() {
  // set the correct timezone
  // Ref: https://randomnerdtutorials.com/esp32-ntp-timezones-daylight-saving/
  Serial.println("=====retrieveTimeFromRTC()=====");
  setenv("TZ", timezone_str, 1);
  tzset();

  RTC_TimeTypeDef timeStruct_RTC;
  RTC_DateTypeDef dateStruct_RTC;
  M5.Rtc.GetTime(&timeStruct_RTC);
  M5.Rtc.GetData(&dateStruct_RTC);

  int isDST = 0;
  EEPROM.get(0, isDST);

  Serial.printf("%d-%d-%d %d:%d:%d (%d)\n", dateStruct_RTC.Year, dateStruct_RTC.Month, dateStruct_RTC.Date, timeStruct_RTC.Hours, timeStruct_RTC.Minutes, timeStruct_RTC.Seconds, isDST);

  struct tm currentTime;
  currentTime.tm_year = dateStruct_RTC.Year - 1900;
  currentTime.tm_mday = dateStruct_RTC.Date;
  currentTime.tm_mon  = dateStruct_RTC.Month;
  currentTime.tm_hour = timeStruct_RTC.Hours;
  currentTime.tm_min  = timeStruct_RTC.Minutes;
  currentTime.tm_sec  = timeStruct_RTC.Seconds;
  currentTime.tm_isdst = isDST;

  time_t rtc_tm = mktime(&currentTime);  // ts
  struct timeval now = { .tv_sec = rtc_tm };
  settimeofday(&now, NULL);

}

// Function to covert %XX back to  +, /, = in URL
int urldecode_inplace(char* content) {
  Serial.println("=====urldecode_inplace()=====");

  if (strlen(content) == 0) {
    Serial.println("Nothing to decode");
    return 0;
  }

  int originalLength = strlen(content);
  int readIndex = 0;
  int writeIndex = 0;

  for (int readIndex=0; readIndex < originalLength; readIndex++) {
    if (content[readIndex] == '%' && content[readIndex+1] == '2' && content[readIndex+2] == 'B') {
      // This is +
      content[writeIndex] = '+';
      readIndex += 2;
    } else if (content[readIndex] == '%' && content[readIndex+1] == '2' && content[readIndex+2] == 'F') {
      // This is /
      content[writeIndex] = '/';
      readIndex += 2;
    } else if (content[readIndex] == '%' && content[readIndex+1] == '3' && content[readIndex+2] == 'D') {
      // This is =
      content[writeIndex] = '=';
      readIndex += 2;
    } else {
      content[writeIndex] = content[readIndex];
    }
    // add writeIndex
    writeIndex++;
  }
  // append the \0 at the end
  content[writeIndex] = 0;
  return writeIndex;  // New string length (not counting \0)
}

bool string_DecodeCb(pb_istream_t *stream, const pb_field_t *field, void **arg) {
  // Ref: https://jpa.kapsi.fi/nanopb/docs/reference.html
  Serial.println("=====string_DecodeCb()=====");
  
  // Let's only handle string with max length of 128 at the moment...
  char buffer[128] = {0};
  int leftByte = stream->bytes_left;
  if (leftByte > sizeof(buffer) - 1)
      return false;
  
  if (!pb_read(stream, (pb_byte_t*)buffer, leftByte))
      return false;
  
  // Copy back to parent decoder
  strcpy((char*)*arg, buffer);
  return true;
}


bool otp_parameters_DecodeCb(pb_istream_t *stream, const pb_field_t *field, void **arg) {
  // Ref: https://jpa.kapsi.fi/nanopb/docs/reference.html

  Serial.println("=====otp_parameters_DecodeCb()=====");
  MigrationPayload_OtpParameters otpParameters = MigrationPayload_OtpParameters_init_zero;

  // also desine callback for the name
  char name_s[128] = {0};
  char secret_s[128] = {0};
  otpParameters.name.funcs.decode = string_DecodeCb;
  otpParameters.name.arg = name_s;
  otpParameters.secret.funcs.decode = string_DecodeCb;
  otpParameters.secret.arg = secret_s;

  if(pb_decode(stream, MigrationPayload_OtpParameters_fields, &otpParameters) == false)
  {
    Serial.print("error decoding: ");
    Serial.println(stream->errmsg);
    return false;
  }

  // save to array
  if (numOfKeyEntry >= MAX_KEY_ENTRIES_NUM) {
    Serial.println("Key number reach max limit");
    return false;
  }

  // pass back to parent decoder
  strcpy(keyList[numOfKeyEntry].name, name_s);
  strcpy(keyList[numOfKeyEntry].secret, secret_s);
  keyList[numOfKeyEntry].otp_type = otpParameters.type;
  numOfKeyEntry++;
  return true;
}

bool getOTPByIndex(int index, char* output) {
  Serial.println("=====getOTPByIndex()=====");
  if (index >= MAX_KEY_ENTRIES_NUM) {
    Serial.println("OTP Index outbound");
    sprintf(output, "ERROR");
    return false;
  }

  // generate TOTP value
  struct tm timeinfo;
  if (!getLocalTime(&timeinfo)){
    Serial.println("Failed to obtain time");
    sprintf(output, "NO TIME");
    return false;
  }
  // Get timestamp
  time_t t_of_day = mktime(&timeinfo);
  //Serial.println(t_of_day);
  OTP_Parms otp_parms = keyList[index];

  if (strlen(otp_parms.secret) == 0) {
    Serial.println("Secret not found");
    sprintf(output, "NA");
    return false;
  }

  Key key((uint8_t*)(otp_parms.secret), strlen(otp_parms.secret));
  long steps = t_of_day / 30;
  SimpleHOTP gen(key, steps);
  uint32_t hotp = gen.generateHOTP();
  sprintf(output, "%06d", hotp);

  Serial.printf("%d# %s: %s\n", index, otp_parms.name, output);
  return true;
}

void printAllLoadedEntries() {
  // !!!DANGEROUS!!!: For debug purpose ONLY.
  // Don't invoke in production, it will output ALL the secret in PLAIN TEXT in Serial Port!!!
  Serial.println("=====printAllLoadedEntries()=====");
  for (int index=0; index < numOfKeyEntry; index++) {
    OTP_Parms otp_parms = keyList[index];
    Serial.printf("%d: %s # %s\n", index, otp_parms.name, otp_parms.secret);
  }
}


bool parseNameAndPlainKey(char* name, char* plain_secret) {
  Serial.println("=====parseNameAndPlainKey()=====");

  if (strlen(name) == 0 || strlen(plain_secret) == 0) {
    // Nothing to process
    return true;
  }

  // save to array
  if (numOfKeyEntry >= MAX_KEY_ENTRIES_NUM) {
    Serial.println("Key entries reach max limit");
    return false;
  }

  strcpy(keyList[numOfKeyEntry].name, name);
  memcpy(keyList[numOfKeyEntry].secret, plain_secret, strlen(plain_secret));
  keyList[numOfKeyEntry].otp_type = 2;

  numOfKeyEntry++;
  return true;
}

bool parseNameAndBase32Key(char* name, char* base32_secret) {
  Serial.println("=====parseNameAndBase32Key()=====");

  if (strlen(name) == 0 || strlen(base32_secret) == 0) {
    // Nothing need to process
    return true;
  }

  // Debug, an example of BASE32-encoded data, obtain from any 2AF register page, eg: otpauth://totp/Firefox:user%40example.com?secret=KNSWG4TFG5ICCQLJNYSGKY3SMV2EWZLZ&issuer=Firefox
  // "KNSWG4TFG5ICCQLJNYSGKY3SMV2EWZLZ" is the base32-encoded string of "Secre7P!Ain$ecretKey"
  //char base32_secret[] = "KNSWG4TFG5ICCQLJNYSGKY3SMV2EWZLZ";  

  byte* plain_key = NULL;
  int plain_key_length = base32.fromBase32((uint8_t*)(base32_secret), strlen(base32_secret), (byte*&)plain_key);

  if (plain_key_length == 0) {
    Serial.println("Base32 Decode Failed");
    return false;
  }

  // save to array
  if (numOfKeyEntry >= MAX_KEY_ENTRIES_NUM) {
    Serial.println("Key entries reach max limit");
    return false;
  }

  // In case we neeed to convert something to base32 string later, i keep the satement as example
  // int plain_key_length = base32.toBase32((uint8_t*)(otp_parms.secret), strlen(otp_parms.secret), (byte*&)plain_key, true);

  strcpy(keyList[numOfKeyEntry].name, name);
  memcpy(keyList[numOfKeyEntry].secret, plain_key, plain_key_length);
  keyList[numOfKeyEntry].otp_type = 2;

  numOfKeyEntry++;
  return true;

}

bool parseGoogleAuthData(char* base64_secret) {
  Serial.println("=====parseGoogleAuthData()=====");

  if (strlen(base64_secret) == 0) {
    // Nothing need to process
    return true;
  }

  // We obtain the Key from GOOGLE authenticator, the data is stored as BASE64-encoded string
  // Data parameter is obtained from the export URL which is generated by GOOGLE authenticator (In base64 encoded format), eg: otpauth-migration://offline?data=Ci4KFFNlY3JlN1AhQWluJGVjcmV0S2V5EhBQbGFpbiBTZWNyZXQgS2V5IAEoATACEAEYASAAKPXz5N0H
  //uint8_t base64_secret[] = "Ci4KFFNlY3JlN1AhQWluJGVjcmV0S2V5EhBQbGFpbiBTZWNyZXQgS2V5IAEoATACEAEYASAAKPXz5N0H"; // Ci4KFFNlY3JlN1AhQWluJGVjcmV0S2V5EhBQbGFpbiBTZWNyZXQgS2V5IAEoATACEAEYASAAKPXz5N0H cotinains the secret "Secre7P!Ain$ecretKey"

  int newStringLen = urldecode_inplace((char*)base64_secret);

  unsigned char protobuf[512];  // protocoBuf can be large because user can export more than 1 accounts in each export URL
  size_t protobuf_len;
  mbedtls_base64_decode(protobuf, 512, &protobuf_len, (uint8_t*)base64_secret, strlen((char*)base64_secret));
  Serial.printf("Stream Length after Base64 decode process: %d\n", protobuf_len);

  // Use Base64 decoder to decode the Data parameter, store in a byte array
  // The base64-decoded data is a Google protobuf stream
  // Use NanoPB to decode that stream

  // Create ProtoBuf Stream
  pb_istream_t protobuf_stream = pb_istream_from_buffer(protobuf, protobuf_len);

  // Parent Message
  MigrationPayload message = MigrationPayload_init_zero;
  // setup the callback before invoke pb_decode
  message.otp_parameters.funcs.decode = otp_parameters_DecodeCb;
  message.otp_parameters.arg = (void*)NULL;
  bool res = pb_decode(&protobuf_stream, MigrationPayload_fields, &message);

  if (!res) {
    Serial.print("submessage Decode fail!: ");
    Serial.println(PB_GET_ERROR(&protobuf_stream));
    return false;
  }
  // The plain text secret is being extracted from the googlee protocol buffer, ready to be used in TOTP generation
  Serial.println("Protobuf decoded successfully.");

  return true;
}

